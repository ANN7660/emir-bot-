const { Client, GatewayIntentBits, PermissionFlagsBits, ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder, StringSelectMenuBuilder } = require('discord.js');
const express = require('express');
const fs = require('fs');

// Configuration du bot
const PREFIX = '!';
const PORT = process.env.PORT || 3000;

// Serveur web pour Render (keep-alive)
const app = express();

app.get('/', (req, res) => {
    res.send('âœ… Bot Discord est en ligne !');
});

app.get('/health', (req, res) => {
    res.json({
        status: 'online',
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Serveur web dÃ©marrÃ© sur le port ${PORT}`);
});

// Client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

// Stockage des configurations par serveur
const serverConfigs = new Map();
const activeTickets = new Map(); // Map<channelId, { userId, createdAt, ticketNumber, category, claimedBy }>
let ticketCounter = 0;

// Fonction pour obtenir la config d'un serveur
function getServerConfig(guildId) {
    if (!serverConfigs.has(guildId)) {
        serverConfigs.set(guildId, {
            welcomeMessage: 'BVN {user} sur {server} ! Nous sommes maintenant {count} membres.',
            welcomeChannelId: null,
            ticketCategoryId: null,
            ticketSupportRoles: [],
            ticketLogChannelId: null,
            maxTicketsPerUser: 3
        });
    }
    return serverConfigs.get(guildId);
}

// Fonction pour formater le message de bienvenue
function formatWelcomeMessage(message, member, guild) {
    return message
        .replace('{user}', `<@${member.id}>`)
        .replace('{server}', guild.name)
        .replace('{count}', guild.memberCount);
}

// Fonction pour crÃ©er une transcription d'un ticket
async function createTranscript(channel) {
    const messages = await channel.messages.fetch({ limit: 100 });
    const sortedMessages = Array.from(messages.values()).reverse();
    
    let transcript = `ğŸ“‹ TRANSCRIPTION DU TICKET: ${channel.name}\n`;
    transcript += `ğŸ“… Date: ${new Date().toLocaleString('fr-FR')}\n`;
    transcript += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
    
    for (const msg of sortedMessages) {
        const timestamp = msg.createdAt.toLocaleString('fr-FR');
        transcript += `[${timestamp}] ${msg.author.tag}:\n`;
        transcript += `${msg.content || '[Embed ou fichier]'}\n\n`;
    }
    
    return transcript;
}

// Fonction pour envoyer les logs
async function sendTicketLog(guild, ticketData, action, closedBy = null, rating = null) {
    const config = getServerConfig(guild.id);
    
    if (!config.ticketLogChannelId) return;
    
    const logChannel = guild.channels.cache.get(config.ticketLogChannelId);
    if (!logChannel) return;
    
    const user = await client.users.fetch(ticketData.userId);
    
    const logEmbed = new EmbedBuilder()
        .setTitle(`ğŸ“Š ${action === 'created' ? 'Ticket CrÃ©Ã©' : 'Ticket FermÃ©'}`)
        .setColor(action === 'created' ? 0x00FF00 : 0xFF0000)
        .addFields(
            { name: 'ğŸ« NumÃ©ro', value: `#${String(ticketData.ticketNumber).padStart(4, '0')}`, inline: true },
            { name: 'ğŸ‘¤ Utilisateur', value: `${user.tag}`, inline: true },
            { name: 'ğŸ“ CatÃ©gorie', value: ticketData.category || 'Non dÃ©finie', inline: true }
        )
        .setTimestamp();
    
    if (action === 'closed') {
        if (closedBy) logEmbed.addFields({ name: 'ğŸ”’ FermÃ© par', value: closedBy.tag, inline: true });
        if (rating) logEmbed.addFields({ name: 'â­ Ã‰valuation', value: rating, inline: true });
        if (ticketData.claimedBy) {
            const claimer = await client.users.fetch(ticketData.claimedBy);
            logEmbed.addFields({ name: 'ğŸ‘¨â€ğŸ’¼ Pris en charge par', value: claimer.tag, inline: true });
        }
    }
    
    await logChannel.send({ embeds: [logEmbed] });
}

// Ã‰vÃ©nement : Bot prÃªt
client.once('ready', () => {
    console.log(`âœ… Bot connectÃ© en tant que ${client.user.tag}`);
    console.log(`ğŸ“Š Sur ${client.guilds.cache.size} serveur(s)`);
});

// Ã‰vÃ©nement : Nouveau membre
client.on('guildMemberAdd', async (member) => {
    const config = getServerConfig(member.guild.id);
    
    let welcomeChannel = null;
    
    if (config.welcomeChannelId) {
        welcomeChannel = member.guild.channels.cache.get(config.welcomeChannelId);
    }
    
    if (!welcomeChannel) {
        welcomeChannel = member.guild.channels.cache.find(ch => 
            ch.name.match(/bienvenue|gÃ©nÃ©ral|general|welcome|accueil/) && 
            ch.permissionsFor(client.user).has(PermissionFlagsBits.SendMessages)
        );
    }
    
    if (!welcomeChannel) {
        welcomeChannel = member.guild.channels.cache.find(ch =>
            ch.isTextBased() &&
            ch.permissionsFor(client.user).has(PermissionFlagsBits.SendMessages)
        );
    }
    
    if (welcomeChannel) {
        const welcomeMsg = formatWelcomeMessage(config.welcomeMessage, member, member.guild);
        try {
            await welcomeChannel.send(welcomeMsg);
        } catch (error) {
            console.error('Erreur lors de l\'envoi du message de bienvenue:', error);
        }
    }
});

// Ã‰vÃ©nement : Interactions (boutons et menus)
client.on('interactionCreate', async (interaction) => {
    // Gestion des boutons
    if (interaction.isButton()) {
        // Bouton crÃ©er un ticket (avec sÃ©lection de catÃ©gorie)
        if (interaction.customId === 'create_ticket') {
            const config = getServerConfig(interaction.guild.id);
            
            if (!config.ticketCategoryId) {
                return interaction.reply({
                    content: 'âŒ Le systÃ¨me de tickets n\'est pas configurÃ© correctement.',
                    ephemeral: true
                });
            }
            
            // VÃ©rifier le nombre de tickets ouverts par l'utilisateur
            const userTickets = Array.from(activeTickets.entries()).filter(
                ([channelId, data]) => data.userId === interaction.user.id && interaction.guild.channels.cache.has(channelId)
            );
            
            if (userTickets.length >= config.maxTicketsPerUser) {
                return interaction.reply({
                    content: `âŒ Vous avez atteint la limite de ${config.maxTicketsPerUser} ticket(s) ouvert(s) simultanÃ©ment.\n\n**Vos tickets ouverts :**\n${userTickets.map(([id]) => `<#${id}>`).join('\n')}`,
                    ephemeral: true
                });
            }
            
            // Menu de sÃ©lection de catÃ©gorie
            const categoryMenu = new StringSelectMenuBuilder()
                .setCustomId('ticket_category')
                .setPlaceholder('ğŸ¯ SÃ©lectionnez une catÃ©gorie')
                .addOptions([
                    {
                        label: 'Support Technique',
                        description: 'ProblÃ¨mes techniques, bugs, erreurs',
                        value: 'support',
                        emoji: 'ğŸ”§'
                    },
                    {
                        label: 'RÃ©clamation',
                        description: 'Signaler un problÃ¨me ou une plainte',
                        value: 'reclamation',
                        emoji: 'âš ï¸'
                    },
                    {
                        label: 'Question GÃ©nÃ©rale',
                        description: 'Questions diverses sur le serveur',
                        value: 'question',
                        emoji: 'â“'
                    },
                    {
                        label: 'Partenariat',
                        description: 'Propositions de partenariat',
                        value: 'partenariat',
                        emoji: 'ğŸ¤'
                    },
                    {
                        label: 'Autre',
                        description: 'Autre sujet',
                        value: 'autre',
                        emoji: 'ğŸ“'
                    }
                ]);
            
            const row = new ActionRowBuilder().addComponents(categoryMenu);
            
            return interaction.reply({
                content: 'ğŸ“‹ **Veuillez sÃ©lectionner une catÃ©gorie pour votre ticket :**',
                components: [row],
                ephemeral: true
            });
        }
        
        // Bouton fermer un ticket
        if (interaction.customId === 'close_ticket') {
            const ticketData = activeTickets.get(interaction.channel.id);
            
            if (!ticketData) {
                return interaction.reply({
                    content: 'âŒ Ce salon n\'est pas un ticket valide.',
                    ephemeral: true
                });
            }
            
            // VÃ©rifier les permissions
            if (ticketData.userId !== interaction.user.id && 
                !interaction.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
                return interaction.reply({
                    content: 'âŒ Seul le crÃ©ateur du ticket ou un modÃ©rateur peut le fermer.',
                    ephemeral: true
                });
            }
            
            // Demander une Ã©valuation si c'est le crÃ©ateur qui ferme
            if (ticketData.userId === interaction.user.id) {
                const ratingRow = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('rating_5')
                            .setLabel('â­â­â­â­â­')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('rating_4')
                            .setLabel('â­â­â­â­')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('rating_3')
                            .setLabel('â­â­â­')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('rating_2')
                            .setLabel('â­â­')
                            .setStyle(ButtonStyle.Danger),
                        new ButtonBuilder()
                            .setCustomId('rating_1')
                            .setLabel('â­')
                            .setStyle(ButtonStyle.Danger)
                    );
                
                const skipRow = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('rating_skip')
                            .setLabel('Passer')
                            .setStyle(ButtonStyle.Secondary)
                    );
                
                return interaction.reply({
                    content: 'â­ **Comment Ã©valuez-vous le support reÃ§u ?**',
                    components: [ratingRow, skipRow],
                    ephemeral: true
                });
            }
            
            // Fermeture directe pour les modÃ©rateurs
            await closeTicket(interaction.channel, interaction.user, ticketData);
        }
        
        // Bouton revendiquer un ticket
        if (interaction.customId === 'claim_ticket') {
            const ticketData = activeTickets.get(interaction.channel.id);
            
            if (!ticketData) {
                return interaction.reply({
                    content: 'âŒ Ce salon n\'est pas un ticket valide.',
                    ephemeral: true
                });
            }
            
            const config = getServerConfig(interaction.guild.id);
            
            // VÃ©rifier que l'utilisateur a un rÃ´le de support
            const hasRole = config.ticketSupportRoles.some(roleId => 
                interaction.member.roles.cache.has(roleId)
            );
            
            if (!hasRole && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
                return interaction.reply({
                    content: 'âŒ Vous devez avoir un rÃ´le de support pour revendiquer ce ticket.',
                    ephemeral: true
                });
            }
            
            if (ticketData.claimedBy) {
                const claimer = await client.users.fetch(ticketData.claimedBy);
                return interaction.reply({
                    content: `âŒ Ce ticket a dÃ©jÃ  Ã©tÃ© revendiquÃ© par ${claimer.tag}`,
                    ephemeral: true
                });
            }
            
            ticketData.claimedBy = interaction.user.id;
            
            const claimEmbed = new EmbedBuilder()
                .setColor(0x00FF00)
                .setDescription(`âœ… **${interaction.user} a pris en charge ce ticket**`)
                .setTimestamp();
            
            await interaction.reply({ embeds: [claimEmbed] });
            
            // DÃ©sactiver le bouton claim
            const message = await interaction.channel.messages.fetch({ limit: 10 });
            const ticketMessage = message.find(m => m.embeds[0]?.title?.includes('Ticket #'));
            
            if (ticketMessage) {
                const components = ticketMessage.components.map(row => {
                    const newRow = ActionRowBuilder.from(row);
                    newRow.components = newRow.components.map(component => {
                        if (component.data.custom_id === 'claim_ticket') {
                            return ButtonBuilder.from(component).setDisabled(true);
                        }
                        return component;
                    });
                    return newRow;
                });
                
                await ticketMessage.edit({ components });
            }
        }
        
        // Boutons d'Ã©valuation
        if (interaction.customId.startsWith('rating_')) {
            const ticketData = activeTickets.get(interaction.channel.id);
            
            if (!ticketData) {
                return interaction.reply({
                    content: 'âŒ Ce salon n\'est pas un ticket valide.',
                    ephemeral: true
                });
            }
            
            let rating = null;
            
            if (interaction.customId !== 'rating_skip') {
                const stars = interaction.customId.split('_')[1];
                rating = 'â­'.repeat(parseInt(stars));
                
                await interaction.update({
                    content: `âœ… Merci pour votre Ã©valuation : ${rating}`,
                    components: []
                });
            } else {
                await interaction.update({
                    content: 'âœ… Ã‰valuation ignorÃ©e.',
                    components: []
                });
            }
            
            await closeTicket(interaction.channel, interaction.user, ticketData, rating);
        }
    }
    
    // Gestion du menu de sÃ©lection
    if (interaction.isStringSelectMenu()) {
        if (interaction.customId === 'ticket_category') {
            const category = interaction.values[0];
            const config = getServerConfig(interaction.guild.id);
            
            await interaction.deferUpdate();
            
            ticketCounter++;
            
            const categoryNames = {
                'support': 'ğŸ”§ Support',
                'reclamation': 'âš ï¸ RÃ©clamation',
                'question': 'â“ Question',
                'partenariat': 'ğŸ¤ Partenariat',
                'autre': 'ğŸ“ Autre'
            };
            
            try {
                // CrÃ©er le salon de ticket
                const ticketChannel = await interaction.guild.channels.create({
                    name: `ticket-${String(ticketCounter).padStart(4, '0')}`,
                    type: 0,
                    parent: config.ticketCategoryId,
                    permissionOverwrites: [
                        {
                            id: interaction.guild.roles.everyone.id,
                            deny: [PermissionFlagsBits.ViewChannel]
                        },
                        {
                            id: interaction.user.id,
                            allow: [
                                PermissionFlagsBits.ViewChannel,
                                PermissionFlagsBits.SendMessages,
                                PermissionFlagsBits.ReadMessageHistory,
                                PermissionFlagsBits.AttachFiles
                            ]
                        },
                        {
                            id: client.user.id,
                            allow: [
                                PermissionFlagsBits.ViewChannel,
                                PermissionFlagsBits.SendMessages,
                                PermissionFlagsBits.ManageChannels
                            ]
                        }
                    ]
                });
                
                // Ajouter les permissions pour les rÃ´les de support
                for (const roleId of config.ticketSupportRoles) {
                    await ticketChannel.permissionOverwrites.edit(roleId, {
                        ViewChannel: true,
                        SendMessages: true,
                        ReadMessageHistory: true
                    });
                }
                
                // Enregistrer le ticket
                const ticketData = {
                    userId: interaction.user.id,
                    createdAt: new Date(),
                    ticketNumber: ticketCounter,
                    category: categoryNames[category],
                    claimedBy: null
                };
                
                activeTickets.set(ticketChannel.id, ticketData);
                
                // CrÃ©er l'embed du ticket
                const ticketEmbed = new EmbedBuilder()
                    .setColor(0x5865F2)
                    .setTitle(`ğŸ« Ticket #${String(ticketCounter).padStart(4, '0')}`)
                    .setDescription(`Bienvenue ${interaction.user} !\n\nMerci d'avoir crÃ©Ã© un ticket. Un membre du staff vous rÃ©pondra bientÃ´t.\n\n**Veuillez dÃ©crire votre problÃ¨me ou votre question ci-dessous.**`)
                    .addFields(
                        {
                            name: 'ğŸ“ CatÃ©gorie',
                            value: categoryNames[category],
                            inline: true
                        },
                        {
                            name: 'ğŸ“ Informations',
                            value: 'Pour fermer ce ticket, cliquez sur le bouton ğŸ”’ ci-dessous.'
                        }
                    )
                    .setFooter({
                        text: `CrÃ©Ã© par ${interaction.user.tag}`,
                        iconURL: interaction.user.displayAvatarURL()
                    })
                    .setTimestamp();
                
                // Boutons pour le ticket
                const buttonRow = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('claim_ticket')
                            .setLabel('ğŸ‘¨â€ğŸ’¼ Prendre en charge')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('close_ticket')
                            .setLabel('ğŸ”’ Fermer le ticket')
                            .setStyle(ButtonStyle.Danger)
                    );
                
                // Mention des rÃ´les de support
                let mentionText = `${interaction.user}`;
                if (config.ticketSupportRoles.length > 0) {
                    const roleMentions = config.ticketSupportRoles.map(roleId => `<@&${roleId}>`).join(' ');
                    mentionText += ` ${roleMentions}`;
                }
                
                await ticketChannel.send({
                    content: mentionText,
                    embeds: [ticketEmbed],
                    components: [buttonRow]
                });
                
                // Log de crÃ©ation
                await sendTicketLog(interaction.guild, ticketData, 'created');
                
                await interaction.editReply({
                    content: `âœ… Votre ticket a Ã©tÃ© crÃ©Ã© : ${ticketChannel}`,
                    components: []
                });
                
            } catch (error) {
                console.error('Erreur lors de la crÃ©ation du ticket:', error);
                await interaction.editReply({
                    content: 'âŒ Une erreur est survenue lors de la crÃ©ation du ticket.',
                    components: []
                });
            }
        }
    }
});

// Fonction pour fermer un ticket
async function closeTicket(channel, closedBy, ticketData, rating = null) {
    try {
        // CrÃ©er la transcription
        const transcript = await createTranscript(channel);
        
        // Envoyer la transcription au crÃ©ateur du ticket
        const user = await client.users.fetch(ticketData.userId);
        
        const transcriptEmbed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle(`ğŸ“‹ Transcription du ticket #${String(ticketData.ticketNumber).padStart(4, '0')}`)
            .setDescription('Voici la transcription complÃ¨te de votre ticket.')
            .addFields(
                { name: 'ğŸ“ CatÃ©gorie', value: ticketData.category || 'Non dÃ©finie', inline: true },
                { name: 'ğŸ“… CrÃ©Ã© le', value: ticketData.createdAt.toLocaleString('fr-FR'), inline: true }
            )
            .setTimestamp();
        
        try {
            await user.send({
                embeds: [transcriptEmbed],
                files: [{
                    attachment: Buffer.from(transcript, 'utf-8'),
                    name: `ticket-${String(ticketData.ticketNumber).padStart(4, '0')}.txt`
                }]
            });
        } catch (error) {
            console.log('Impossible d\'envoyer la transcription en MP');
        }
        
        // Log de fermeture
        await sendTicketLog(channel.guild, ticketData, 'closed', closedBy, rating);
        
        // Message de fermeture
        const closeEmbed = new EmbedBuilder()
            .setColor(0xFF0000)
            .setTitle('ğŸ”’ Ticket en cours de fermeture')
            .setDescription('Ce ticket sera supprimÃ© dans **5 secondes**...')
            .setFooter({
                text: `FermÃ© par ${closedBy.tag}`,
                iconURL: closedBy.displayAvatarURL()
            })
            .setTimestamp();
        
        await channel.send({ embeds: [closeEmbed] });
        
        setTimeout(async () => {
            activeTickets.delete(channel.id);
            await channel.delete();
        }, 5000);
        
    } catch (error) {
        console.error('Erreur lors de la fermeture du ticket:', error);
    }
}

// Ã‰vÃ©nement : Messages
client.on('messageCreate', async (message) => {
    if (message.author.bot || !message.content.startsWith(PREFIX)) return;
    
    const args = message.content.slice(PREFIX.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    
    // Commande !help
    if (command === 'help') {
        const embed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle('ğŸ“š Commandes du Bot')
            .addFields(
                {
                    name: 'ğŸ‘‹ Bienvenue',
                    value: '`!bvntest` - Tester le message de bienvenue\n`!bvnmsg <message>` - Configurer le message (ModÃ©rateurs)'
                },
                {
                    name: 'ğŸ« Tickets',
                    value: '`!ticketpanel` - CrÃ©er le panel de tickets (Admin)\n`!ticketsetup` - Configurer la catÃ©gorie (Admin)\n`!roleticket <@role>` - Ajouter un rÃ´le de support (Admin)\n`!ticketlog <#salon>` - DÃ©finir le salon de logs (Admin)\n`!ticketlimit <nombre>` - Limite de tickets par utilisateur (Admin)\n`!ticketstats` - Voir les statistiques des tickets'
                },
                {
                    name: 'ğŸ”’ ModÃ©ration',
                    value: '`!lock` - Verrouiller le salon actuel\n`!unlock` - DÃ©verrouiller le salon actuel'
                },
                {
                    name: 'ğŸ“ Variables disponibles',
                    value: '`{user}` - Mention du membre\n`{server}` - Nom du serveur\n`{count}` - Nombre de membres'
                }
            )
            .setFooter({ text: 'Utilisez ! comme prÃ©fixe pour toutes les commandes' });
        
        return message.reply({ embeds: [embed] });
    }
    
    // Commande !bvntest
    if (command === 'bvntest') {
        const config = getServerConfig(message.guild.id);
        const testMsg = formatWelcomeMessage(config.welcomeMessage, message.member, message.guild);
        
        return message.reply({
            content: 'ğŸ§ª **Test du message de bienvenue :**\n' + testMsg,
            allowedMentions: { parse: [] }
        });
    }
    
    // Commande !bvnmsg
    if (command === 'bvnmsg') {
        if (!message.member.permissions.has(PermissionFlagsBits.ManageGuild)) {
            return message.reply('âŒ Vous devez avoir la permission "GÃ©rer le serveur" pour utiliser cette commande.');
        }
        
        const newMessage = args.join(' ');
        
        if (!newMessage) {
            return message.reply('âŒ Veuillez fournir un message.\n**Exemple :** `!bvnmsg BVN {user} sur {server} !`');
        }
        
        const config = getServerConfig(message.guild.id);
        config.welcomeMessage = newMessage;
        config.welcomeChannelId = message.channel.id;
        
        const preview = formatWelcomeMessage(newMessage, message.member, message.guild);
        
        return message.reply({
            content: `âœ… **Message de bienvenue configurÃ© !**\n\n**AperÃ§u :**\n${preview}\n\n*Les messages de bienvenue seront envoyÃ©s dans ce salon.*`,
            allowedMentions: { parse: [] }
        });
    }
    
    // Commande !ticketsetup
    if (command === 'ticketsetup') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const config = getServerConfig(message.guild.id);
        
        try {
            let ticketCategory = message.guild.channels.cache.find(
                ch => ch.name === 'ğŸ« TICKETS' && ch.type === 4
            );
            
            if (!ticketCategory) {
                ticketCategory = await message.guild.channels.create({
                    name: 'ğŸ« TICKETS',
                    type: 4,
                    permissionOverwrites: [
                        {
                            id: message.guild.roles.everyone.id,
                            deny: [PermissionFlagsBits.ViewChannel]
                        },
                        {
                            id: client.user.id,
                            allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ManageChannels]
                        }
                    ]
                });
            }
            
            config.ticketCategoryId = ticketCategory.id;
            
            return message.reply(`âœ… **SystÃ¨me de tickets configurÃ© !**\n\nğŸ“ CatÃ©gorie : ${ticketCategory.name}\nğŸ’¡ Utilisez \`!ticketpanel\` pour crÃ©er le panel de tickets.`);
        } catch (error) {
            console.error('Erreur lors de la configuration des tickets:', error);
            return message.reply('âŒ Erreur lors de la configuration. VÃ©rifiez que le bot a les permissions "GÃ©rer les salons".');
        }
    }
    
    // Commande !roleticket
    if (command === 'roleticket') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const role = message.mentions.roles.first();
        
        if (!role) {
            return message.reply('âŒ Veuillez mentionner un rÃ´le.\n**Exemple :** `!roleticket @Support`');
        }
        
        const config = getServerConfig(message.guild.id);
        
        if (config.ticketSupportRoles.includes(role.id)) {
            return message.reply(`âŒ Le rÃ´le ${role} est dÃ©jÃ  configurÃ© comme rÃ´le de support.`);
        }
        
        config.ticketSupportRoles.push(role.id);
        
        return message.reply(`âœ… Le rÃ´le ${role} sera maintenant mentionnÃ© lors de l'ouverture d'un ticket.`);
    }
    
    // Commande !ticketlog
    if (command === 'ticketlog') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const channel = message.mentions.channels.first();
        
        if (!channel) {
            return message.reply('âŒ Veuillez mentionner un salon.\n**Exemple :** `!ticketlog #logs-tickets`');
        }
        
        const config = getServerConfig(message.guild.id);
        config.ticketLogChannelId = channel.id;
        
        return message.reply(`âœ… Les logs des tickets seront envoyÃ©s dans ${channel}`);
    }
    
    // Commande !ticketlimit
    if (command === 'ticketlimit') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const limit = parseInt(args[0]);
        
        if (isNaN(limit) || limit < 1 || limit > 10) {
            return message.reply('âŒ Veuillez fournir un nombre entre 1 et 10.\n**Exemple :** `!ticketlimit 3`');
        }
        
        const config = getServerConfig(message.guild.id);
        config.maxTicketsPerUser = limit;
        
        return message.reply(`âœ… La limite de tickets par utilisateur est maintenant de **${limit}**.`);
    }
    
    // Commande !ticketstats
    if (command === 'ticketstats') {
        const guildTickets = Array.from(activeTickets.entries()).filter(
            ([channelId]) => message.guild.channels.cache.has(channelId)
        );
        
        const totalOpen = guildTickets.length;
        const totalCreated = ticketCounter;
        const totalClosed = totalCreated - totalOpen;
        
        // Statistiques par catÃ©gorie
        const categoryStats = {};
        guildTickets.forEach(([_, data]) => {
            const cat = data.category || 'Non dÃ©finie';
            categoryStats[cat] = (categoryStats[cat] || 0) + 1;
        });
        
        const statsEmbed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle('ğŸ“Š Statistiques des Tickets')
            .addFields(
                { name: 'ğŸ« Total crÃ©Ã©s', value: `${totalCreated}`, inline: true },
                { name: 'âœ… Tickets fermÃ©s', value: `${totalClosed}`, inline: true },
                { name: 'ğŸ”“ Tickets ouverts', value: `${totalOpen}`, inline: true }
            )
            .setTimestamp();
        
        if (Object.keys(categoryStats).length > 0) {
            const categoryText = Object.entries(categoryStats)
                .map(([cat, count]) => `${cat}: **${count}**`)
                .join('\n');
            statsEmbed.addFields({ name: 'ğŸ“ Par catÃ©gorie (ouverts)', value: categoryText });
        }
        
        return message.reply({ embeds: [statsEmbed] });
    }
    
    // Commande !ticketpanel
    if (command === 'ticketpanel') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const config = getServerConfig(message.guild.id);
        
        if (!config.ticketCategoryId) {
            return message.reply('âŒ Vous devez d\'abord configurer le systÃ¨me avec `!ticketsetup`.');
        }
        
        const panelEmbed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle('ğŸ« Support - CrÃ©er un ticket')
            .setDescription('Besoin d\'aide ? Cliquez sur le bouton ci-dessous pour crÃ©er un ticket de support.\n\nUn membre de notre Ã©quipe vous rÃ©pondra dÃ¨s que possible.')
            .addFields({
                name: 'ğŸ“‹ Comment Ã§a marche ?',
                value: '1ï¸âƒ£ Cliquez sur le bouton "CrÃ©er un ticket"\n2ï¸âƒ£ SÃ©lectionnez une catÃ©gorie\n3ï¸âƒ£ Un salon privÃ© sera crÃ©Ã© pour vous\n4ï¸âƒ£ DÃ©crivez votre problÃ¨me\n5ï¸âƒ£ Attendez la rÃ©ponse du staff'
            })
            .addFields({
                name: 'âœ¨ FonctionnalitÃ©s',
                value: 'â€¢ ğŸ“ CatÃ©gories multiples\nâ€¢ ğŸ‘¨â€ğŸ’¼ Revendication par le staff\nâ€¢ ğŸ“‹ Transcription automatique\nâ€¢ â­ SystÃ¨me d\'Ã©valuation'
            })
            .setFooter({ text: 'SystÃ¨me de tickets avancÃ©' })
            .setTimestamp();
        
        const button = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_ticket')
                    .setLabel('ğŸ“© CrÃ©er un ticket')
                    .setStyle(ButtonStyle.Primary)
            );
        
        try {
            await message.channel.send({
                embeds: [panelEmbed],
                components: [button]
            });
            
            await message.delete().catch(() => {});
        } catch (error) {
            console.error('Erreur lors de la crÃ©ation du panel:', error);
            return message.reply('âŒ Une erreur est survenue lors de la crÃ©ation du panel.');
        }
    }
    
    // Commande !lock
    if (command === 'lock') {
        if (!message.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
            return message.reply('âŒ Vous devez avoir la permission "GÃ©rer les salons" pour utiliser cette commande.');
        }
        
        const channel = message.channel;
        const everyoneRole = message.guild.roles.everyone;
        
        try {
            await channel.permissionOverwrites.edit(everyoneRole, {
                SendMessages: false
            });
            
            return message.reply('ğŸ”’ **Salon verrouillÃ© !** Les membres ne peuvent plus envoyer de messages.');
        } catch (error) {
            console.error('Erreur lors du verrouillage:', error);
            return message.reply('âŒ Erreur lors du verrouillage du salon. VÃ©rifiez que le bot a les permissions nÃ©cessaires.');
        }
    }
    
    // Commande !unlock
    if (command === 'unlock') {
        if (!message.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
            return message.reply('âŒ Vous devez avoir la permission "GÃ©rer les salons" pour utiliser cette commande.');
        }
        
        const channel = message.channel;
        const everyoneRole = message.guild.roles.everyone;
        
        try {
            await channel.permissionOverwrites.edit(everyoneRole, {
                SendMessages: null
            });
            
            return message.reply('ğŸ”“ **Salon dÃ©verrouillÃ© !** Les membres peuvent Ã  nouveau envoyer des messages.');
        } catch (error) {
            console.error('Erreur lors du dÃ©verrouillage:', error);
            return message.reply('âŒ Erreur lors du dÃ©verrouillage du salon. VÃ©rifiez que le bot a les permissions nÃ©cessaires.');
        }
    }
});

// Gestion des erreurs
client.on('error', error => {
    console.error('Erreur du client Discord:', error);
});

process.on('unhandledRejection', error => {
    console.error('Erreur non gÃ©rÃ©e:', error);
});

// Connexion du bot
const TOKEN = process.env.DISCORD_TOKEN;

if (!TOKEN) {
    console.error('âŒ DISCORD_TOKEN manquant dans les variables d\'environnement !');
    process.exit(1);
}

client.login(TOKEN);
