const { Client, GatewayIntentBits, PermissionFlagsBits, ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder } = require('discord.js');
const express = require('express');

// Configuration du bot
const PREFIX = '!';
const PORT = process.env.PORT || 3000;

// Serveur web pour Render (keep-alive)
const app = express();

app.get('/', (req, res) => {
    res.send('âœ… Bot Discord est en ligne !');
});

app.get('/health', (req, res) => {
    res.json({
        status: 'online',
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Serveur web dÃ©marrÃ© sur le port ${PORT}`);
});

// Client Discord
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMembers,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

// Stockage des configurations par serveur
const serverConfigs = new Map();
const activeTickets = new Map(); // Map<channelId, { userId, createdAt, ticketNumber }>
let ticketCounter = 0;

// Fonction pour obtenir la config d'un serveur
function getServerConfig(guildId) {
    if (!serverConfigs.has(guildId)) {
        serverConfigs.set(guildId, {
            welcomeMessage: 'BVN {user} sur {server} ! Nous sommes maintenant {count} membres.',
            welcomeChannelId: null,
            ticketCategoryId: null,
            ticketSupportRoles: [] // Array de role IDs
        });
    }
    return serverConfigs.get(guildId);
}

// Fonction pour formater le message de bienvenue
function formatWelcomeMessage(message, member, guild) {
    return message
        .replace('{user}', `<@${member.id}>`)
        .replace('{server}', guild.name)
        .replace('{count}', guild.memberCount);
}

// Ã‰vÃ©nement : Bot prÃªt
client.once('ready', () => {
    console.log(`âœ… Bot connectÃ© en tant que ${client.user.tag}`);
    console.log(`ğŸ“Š Sur ${client.guilds.cache.size} serveur(s)`);
});

// Ã‰vÃ©nement : Nouveau membre
client.on('guildMemberAdd', async (member) => {
    const config = getServerConfig(member.guild.id);
    
    let welcomeChannel = null;
    
    if (config.welcomeChannelId) {
        welcomeChannel = member.guild.channels.cache.get(config.welcomeChannelId);
    }
    
    if (!welcomeChannel) {
        welcomeChannel = member.guild.channels.cache.find(ch => 
            ch.name.match(/bienvenue|gÃ©nÃ©ral|general|welcome|accueil/) && 
            ch.permissionsFor(client.user).has(PermissionFlagsBits.SendMessages)
        );
    }
    
    if (!welcomeChannel) {
        welcomeChannel = member.guild.channels.cache.find(ch =>
            ch.isTextBased() &&
            ch.permissionsFor(client.user).has(PermissionFlagsBits.SendMessages)
        );
    }
    
    if (welcomeChannel) {
        const welcomeMsg = formatWelcomeMessage(config.welcomeMessage, member, member.guild);
        try {
            await welcomeChannel.send(welcomeMsg);
        } catch (error) {
            console.error('Erreur lors de l\'envoi du message de bienvenue:', error);
        }
    }
});

// Ã‰vÃ©nement : Interactions (boutons)
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isButton()) return;
    
    // Bouton crÃ©er un ticket
    if (interaction.customId === 'create_ticket') {
        const config = getServerConfig(interaction.guild.id);
        
        if (!config.ticketCategoryId) {
            return interaction.reply({
                content: 'âŒ Le systÃ¨me de tickets n\'est pas configurÃ© correctement.',
                ephemeral: true
            });
        }
        
        // VÃ©rifier si l'utilisateur a dÃ©jÃ  un ticket ouvert
        const existingTicket = Array.from(activeTickets.entries()).find(
            ([channelId, data]) => data.userId === interaction.user.id && interaction.guild.channels.cache.has(channelId)
        );
        
        if (existingTicket) {
            const [channelId] = existingTicket;
            return interaction.reply({
                content: `âŒ Vous avez dÃ©jÃ  un ticket ouvert : <#${channelId}>`,
                ephemeral: true
            });
        }
        
        await interaction.deferReply({ ephemeral: true });
        
        ticketCounter++;
        
        try {
            // CrÃ©er le salon de ticket
            const ticketChannel = await interaction.guild.channels.create({
                name: `ticket-${String(ticketCounter).padStart(4, '0')}`,
                type: 0,
                parent: config.ticketCategoryId,
                permissionOverwrites: [
                    {
                        id: interaction.guild.roles.everyone.id,
                        deny: [PermissionFlagsBits.ViewChannel]
                    },
                    {
                        id: interaction.user.id,
                        allow: [
                            PermissionFlagsBits.ViewChannel,
                            PermissionFlagsBits.SendMessages,
                            PermissionFlagsBits.ReadMessageHistory,
                            PermissionFlagsBits.AttachFiles
                        ]
                    },
                    {
                        id: client.user.id,
                        allow: [
                            PermissionFlagsBits.ViewChannel,
                            PermissionFlagsBits.SendMessages,
                            PermissionFlagsBits.ManageChannels
                        ]
                    }
                ]
            });
            
            // Ajouter les permissions pour les rÃ´les de support
            for (const roleId of config.ticketSupportRoles) {
                await ticketChannel.permissionOverwrites.edit(roleId, {
                    ViewChannel: true,
                    SendMessages: true,
                    ReadMessageHistory: true
                });
            }
            
            // Enregistrer le ticket
            activeTickets.set(ticketChannel.id, {
                userId: interaction.user.id,
                createdAt: new Date(),
                ticketNumber: ticketCounter
            });
            
            // CrÃ©er l'embed du ticket
            const ticketEmbed = new EmbedBuilder()
                .setColor(0x5865F2)
                .setTitle(`ğŸ« Ticket #${String(ticketCounter).padStart(4, '0')}`)
                .setDescription(`Bienvenue ${interaction.user} !\n\nMerci d'avoir crÃ©Ã© un ticket. Un membre du staff vous rÃ©pondra bientÃ´t.\n\n**Veuillez dÃ©crire votre problÃ¨me ou votre question ci-dessous.**`)
                .addFields({
                    name: 'ğŸ“ Informations',
                    value: 'Pour fermer ce ticket, cliquez sur le bouton ğŸ”’ Fermer ci-dessous.'
                })
                .setFooter({
                    text: `CrÃ©Ã© par ${interaction.user.tag}`,
                    iconURL: interaction.user.displayAvatarURL()
                })
                .setTimestamp();
            
            // Bouton pour fermer le ticket
            const closeButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('close_ticket')
                        .setLabel('ğŸ”’ Fermer le ticket')
                        .setStyle(ButtonStyle.Danger)
                );
            
            // Mention des rÃ´les de support
            let mentionText = `${interaction.user}`;
            if (config.ticketSupportRoles.length > 0) {
                const roleMentions = config.ticketSupportRoles.map(roleId => `<@&${roleId}>`).join(' ');
                mentionText += ` ${roleMentions}`;
            }
            
            await ticketChannel.send({
                content: mentionText,
                embeds: [ticketEmbed],
                components: [closeButton]
            });
            
            await interaction.editReply({
                content: `âœ… Votre ticket a Ã©tÃ© crÃ©Ã© : ${ticketChannel}`,
            });
            
        } catch (error) {
            console.error('Erreur lors de la crÃ©ation du ticket:', error);
            await interaction.editReply({
                content: 'âŒ Une erreur est survenue lors de la crÃ©ation du ticket.'
            });
        }
    }
    
    // Bouton fermer un ticket
    if (interaction.customId === 'close_ticket') {
        const ticketData = activeTickets.get(interaction.channel.id);
        
        if (!ticketData) {
            return interaction.reply({
                content: 'âŒ Ce salon n\'est pas un ticket valide.',
                ephemeral: true
            });
        }
        
        // VÃ©rifier que c'est le crÃ©ateur du ticket ou un modÃ©rateur
        if (ticketData.userId !== interaction.user.id && 
            !interaction.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
            return interaction.reply({
                content: 'âŒ Seul le crÃ©ateur du ticket ou un modÃ©rateur peut le fermer.',
                ephemeral: true
            });
        }
        
        try {
            const closeEmbed = new EmbedBuilder()
                .setColor(0xFF0000)
                .setTitle('ğŸ”’ Ticket en cours de fermeture')
                .setDescription('Ce ticket sera supprimÃ© dans **5 secondes**...')
                .setFooter({
                    text: `FermÃ© par ${interaction.user.tag}`,
                    iconURL: interaction.user.displayAvatarURL()
                })
                .setTimestamp();
            
            await interaction.reply({ embeds: [closeEmbed] });
            
            setTimeout(async () => {
                activeTickets.delete(interaction.channel.id);
                await interaction.channel.delete();
            }, 5000);
            
        } catch (error) {
            console.error('Erreur lors de la fermeture du ticket:', error);
            await interaction.reply({
                content: 'âŒ Une erreur est survenue lors de la fermeture du ticket.',
                ephemeral: true
            });
        }
    }
});

// Ã‰vÃ©nement : Messages
client.on('messageCreate', async (message) => {
    if (message.author.bot || !message.content.startsWith(PREFIX)) return;
    
    const args = message.content.slice(PREFIX.length).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    
    // Commande !help
    if (command === 'help') {
        const embed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle('ğŸ“š Commandes du Bot')
            .addFields(
                {
                    name: 'ğŸ‘‹ Bienvenue',
                    value: '`!bvntest` - Tester le message de bienvenue\n`!bvnmsg <message>` - Configurer le message (ModÃ©rateurs uniquement)'
                },
                {
                    name: 'ğŸ« Tickets',
                    value: '`!ticketpanel` - CrÃ©er le panel de tickets (Admin)\n`!ticketsetup` - Configurer la catÃ©gorie des tickets (Admin)\n`!roleticket <@role>` - Ajouter un rÃ´le de support (Admin)'
                },
                {
                    name: 'ğŸ”’ ModÃ©ration',
                    value: '`!lock` - Verrouiller le salon actuel\n`!unlock` - DÃ©verrouiller le salon actuel'
                },
                {
                    name: 'ğŸ“ Variables disponibles',
                    value: '`{user}` - Mention du membre\n`{server}` - Nom du serveur\n`{count}` - Nombre de membres'
                }
            )
            .setFooter({ text: 'Utilisez ! comme prÃ©fixe pour toutes les commandes' });
        
        return message.reply({ embeds: [embed] });
    }
    
    // Commande !bvntest
    if (command === 'bvntest') {
        const config = getServerConfig(message.guild.id);
        const testMsg = formatWelcomeMessage(config.welcomeMessage, message.member, message.guild);
        
        return message.reply({
            content: 'ğŸ§ª **Test du message de bienvenue :**\n' + testMsg,
            allowedMentions: { parse: [] }
        });
    }
    
    // Commande !bvnmsg
    if (command === 'bvnmsg') {
        if (!message.member.permissions.has(PermissionFlagsBits.ManageGuild)) {
            return message.reply('âŒ Vous devez avoir la permission "GÃ©rer le serveur" pour utiliser cette commande.');
        }
        
        const newMessage = args.join(' ');
        
        if (!newMessage) {
            return message.reply('âŒ Veuillez fournir un message.\n**Exemple :** `!bvnmsg BVN {user} sur {server} !`');
        }
        
        const config = getServerConfig(message.guild.id);
        config.welcomeMessage = newMessage;
        config.welcomeChannelId = message.channel.id;
        
        const preview = formatWelcomeMessage(newMessage, message.member, message.guild);
        
        return message.reply({
            content: `âœ… **Message de bienvenue configurÃ© !**\n\n**AperÃ§u :**\n${preview}\n\n*Les messages de bienvenue seront envoyÃ©s dans ce salon.*`,
            allowedMentions: { parse: [] }
        });
    }
    
    // Commande !ticketsetup
    if (command === 'ticketsetup') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const config = getServerConfig(message.guild.id);
        
        try {
            let ticketCategory = message.guild.channels.cache.find(
                ch => ch.name === 'ğŸ« TICKETS' && ch.type === 4
            );
            
            if (!ticketCategory) {
                ticketCategory = await message.guild.channels.create({
                    name: 'ğŸ« TICKETS',
                    type: 4,
                    permissionOverwrites: [
                        {
                            id: message.guild.roles.everyone.id,
                            deny: [PermissionFlagsBits.ViewChannel]
                        },
                        {
                            id: client.user.id,
                            allow: [PermissionFlagsBits.ViewChannel, PermissionFlagsBits.ManageChannels]
                        }
                    ]
                });
            }
            
            config.ticketCategoryId = ticketCategory.id;
            
            return message.reply(`âœ… **SystÃ¨me de tickets configurÃ© !**\n\nğŸ“ CatÃ©gorie : ${ticketCategory.name}\nğŸ’¡ Utilisez \`!ticketpanel\` pour crÃ©er le panel de tickets.`);
        } catch (error) {
            console.error('Erreur lors de la configuration des tickets:', error);
            return message.reply('âŒ Erreur lors de la configuration. VÃ©rifiez que le bot a les permissions "GÃ©rer les salons".');
        }
    }
    
    // Commande !roleticket
    if (command === 'roleticket') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const role = message.mentions.roles.first();
        
        if (!role) {
            return message.reply('âŒ Veuillez mentionner un rÃ´le.\n**Exemple :** `!roleticket @Support`');
        }
        
        const config = getServerConfig(message.guild.id);
        
        if (config.ticketSupportRoles.includes(role.id)) {
            return message.reply(`âŒ Le rÃ´le ${role} est dÃ©jÃ  configurÃ© comme rÃ´le de support.`);
        }
        
        config.ticketSupportRoles.push(role.id);
        
        return message.reply(`âœ… Le rÃ´le ${role} sera maintenant mentionnÃ© lors de l'ouverture d'un ticket.`);
    }
    
    // Commande !ticketpanel
    if (command === 'ticketpanel') {
        if (!message.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return message.reply('âŒ Vous devez Ãªtre administrateur pour utiliser cette commande.');
        }
        
        const config = getServerConfig(message.guild.id);
        
        if (!config.ticketCategoryId) {
            return message.reply('âŒ Vous devez d\'abord configurer le systÃ¨me avec `!ticketsetup`.');
        }
        
        const panelEmbed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle('ğŸ« Support - CrÃ©er un ticket')
            .setDescription('Besoin d\'aide ? Cliquez sur le bouton ci-dessous pour crÃ©er un ticket de support.\n\nUn membre de notre Ã©quipe vous rÃ©pondra dÃ¨s que possible.')
            .addFields({
                name: 'ğŸ“‹ Comment Ã§a marche ?',
                value: '1ï¸âƒ£ Cliquez sur le bouton "CrÃ©er un ticket"\n2ï¸âƒ£ Un salon privÃ© sera crÃ©Ã© pour vous\n3ï¸âƒ£ DÃ©crivez votre problÃ¨me\n4ï¸âƒ£ Attendez la rÃ©ponse du staff'
            })
            .setFooter({ text: 'SystÃ¨me de tickets' })
            .setTimestamp();
        
        const button = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('create_ticket')
                    .setLabel('ğŸ“© CrÃ©er un ticket')
                    .setStyle(ButtonStyle.Primary)
            );
        
        try {
            await message.channel.send({
                embeds: [panelEmbed],
                components: [button]
            });
            
            await message.delete().catch(() => {});
        } catch (error) {
            console.error('Erreur lors de la crÃ©ation du panel:', error);
            return message.reply('âŒ Une erreur est survenue lors de la crÃ©ation du panel.');
        }
    }
    
    // Commande !lock
    if (command === 'lock') {
        if (!message.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
            return message.reply('âŒ Vous devez avoir la permission "GÃ©rer les salons" pour utiliser cette commande.');
        }
        
        const channel = message.channel;
        const everyoneRole = message.guild.roles.everyone;
        
        try {
            await channel.permissionOverwrites.edit(everyoneRole, {
                SendMessages: false
            });
            
            return message.reply('ğŸ”’ **Salon verrouillÃ© !** Les membres ne peuvent plus envoyer de messages.');
        } catch (error) {
            console.error('Erreur lors du verrouillage:', error);
            return message.reply('âŒ Erreur lors du verrouillage du salon. VÃ©rifiez que le bot a les permissions nÃ©cessaires.');
        }
    }
    
    // Commande !unlock
    if (command === 'unlock') {
        if (!message.member.permissions.has(PermissionFlagsBits.ManageChannels)) {
            return message.reply('âŒ Vous devez avoir la permission "GÃ©rer les salons" pour utiliser cette commande.');
        }
        
        const channel = message.channel;
        const everyoneRole = message.guild.roles.everyone;
        
        try {
            await channel.permissionOverwrites.edit(everyoneRole, {
                SendMessages: null
            });
            
            return message.reply('ğŸ”“ **Salon dÃ©verrouillÃ© !** Les membres peuvent Ã  nouveau envoyer des messages.');
        } catch (error) {
            console.error('Erreur lors du dÃ©verrouillage:', error);
            return message.reply('âŒ Erreur lors du dÃ©verrouillage du salon. VÃ©rifiez que le bot a les permissions nÃ©cessaires.');
        }
    }
});

// Gestion des erreurs
client.on('error', error => {
    console.error('Erreur du client Discord:', error);
});

process.on('unhandledRejection', error => {
    console.error('Erreur non gÃ©rÃ©e:', error);
});

// Connexion du bot
const TOKEN = process.env.DISCORD_TOKEN;

if (!TOKEN) {
    console.error('âŒ DISCORD_TOKEN manquant dans les variables d\'environnement !');
    process.exit(1);
}

client.login(TOKEN);
